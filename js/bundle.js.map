{"version":3,"sources":["webpack:///webpack/bootstrap c609409cee9d7f2e77d5","webpack:///./js/game.js","webpack:///./js/maze.js","webpack:///./js/maze_generator.js","webpack:///./js/player.js","webpack:///./js/trail.js"],"names":[],"mappings":";AAAA;AACA;;AAEA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;;AAEA;AACA;;AAEA;AACA;AACA;;;AAGA;AACA;;AAEA;AACA;;AAEA;AACA,mDAA2C,cAAc;;AAEzD;AACA;AACA;AACA;AACA;AACA;AACA;AACA,aAAK;AACL;AACA;;AAEA;AACA;AACA;AACA,mCAA2B,0BAA0B,EAAE;AACvD,yCAAiC,eAAe;AAChD;AACA;AACA;;AAEA;AACA,8DAAsD,+DAA+D;;AAErH;AACA;;AAEA;AACA;;;;;;;;;;AChEA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;;AAEA;AACA,YAAY,oCAAoC;AAChD;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;;AAEA;;;;;;;;AChHA;AACA;AACA;AACA;;AAEA;AACA;;AAEA,uBAAuB;AACvB;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA,mBAAmB,UAAU;AAC7B;AACA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;;AAEA;AACA;;AAEA;AACA;AACA;AACA;AACA,gBAAgB;AAChB,gBAAgB;AAChB,sBAAsB;;AAEtB;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;AACA;;AAEA,8BAA8B,mBAAmB;AACjD;AACA;AACA,KAAK;AACL;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;;AAEA;AACA,+CAA+C,iBAAiB;AAChE;AACA,+CAA+C,iBAAiB;AAChE;AACA,+CAA+C,iBAAiB;AAChE;AACA,+CAA+C,iBAAiB;;AAEhE;AACA;AACA,OAAO;AACP;AACA,KAAK;;AAEL;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;;AAEA;AACA;AACA,KAAK;;AAEL;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,KAAK;AACL;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;;AAEA;;AAEA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;;AAEA;AACA;AACA,SAAS;AACT,OAAO;AACP,KAAK;AACL;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;;;;;;;;;;ACrPA;;AAEA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA,CAAC;;;;;;;;;ACVD;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;;AAEA;;AAEA;AACA,WAAW,uDAAuD;AAClE,aAAa,qDAAqD;AAClE,aAAa,uDAAuD;AACpE,cAAc;AACd;;AAEA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;;AAEA;;AAEA;AACA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA,mBAAmB,qBAAqB;AACxC,mBAAmB,qBAAqB;AACxC;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;;AAEA;AACA;;AAEA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;;AAEA;;;;;;;;AC3FA;AACA;AACA;AACA,kBAAkB,OAAO;AACzB;;AAEA;AACA,oBAAoB,OAAO;AAC3B;;AAEA;AACA;AACA;AACA;AACA;AACA,KAAK;AACL;AACA;AACA;AACA;AACA;;AAEA","file":"./bundle.js","sourcesContent":[" \t// The module cache\n \tvar installedModules = {};\n\n \t// The require function\n \tfunction __webpack_require__(moduleId) {\n\n \t\t// Check if module is in cache\n \t\tif(installedModules[moduleId])\n \t\t\treturn installedModules[moduleId].exports;\n\n \t\t// Create a new module (and put it into the cache)\n \t\tvar module = installedModules[moduleId] = {\n \t\t\ti: moduleId,\n \t\t\tl: false,\n \t\t\texports: {}\n \t\t};\n\n \t\t// Execute the module function\n \t\tmodules[moduleId].call(module.exports, module, module.exports, __webpack_require__);\n\n \t\t// Flag the module as loaded\n \t\tmodule.l = true;\n\n \t\t// Return the exports of the module\n \t\treturn module.exports;\n \t}\n\n\n \t// expose the modules object (__webpack_modules__)\n \t__webpack_require__.m = modules;\n\n \t// expose the module cache\n \t__webpack_require__.c = installedModules;\n\n \t// identity function for calling harmony imports with the correct context\n \t__webpack_require__.i = function(value) { return value; };\n\n \t// define getter function for harmony exports\n \t__webpack_require__.d = function(exports, name, getter) {\n \t\tif(!__webpack_require__.o(exports, name)) {\n \t\t\tObject.defineProperty(exports, name, {\n \t\t\t\tconfigurable: false,\n \t\t\t\tenumerable: true,\n \t\t\t\tget: getter\n \t\t\t});\n \t\t}\n \t};\n\n \t// getDefaultExport function for compatibility with non-harmony modules\n \t__webpack_require__.n = function(module) {\n \t\tvar getter = module && module.__esModule ?\n \t\t\tfunction getDefault() { return module['default']; } :\n \t\t\tfunction getModuleExports() { return module; };\n \t\t__webpack_require__.d(getter, 'a', getter);\n \t\treturn getter;\n \t};\n\n \t// Object.prototype.hasOwnProperty.call\n \t__webpack_require__.o = function(object, property) { return Object.prototype.hasOwnProperty.call(object, property); };\n\n \t// __webpack_public_path__\n \t__webpack_require__.p = \"\";\n\n \t// Load entry module and return exports\n \treturn __webpack_require__(__webpack_require__.s = 2);\n\n\n\n// WEBPACK FOOTER //\n// webpack/bootstrap c609409cee9d7f2e77d5","import Player from './player';\nimport Maze from './maze';\n\n// NEXT --> if you pass a branching point have the trail leave a node there,\n// just a fatter point that sticks out of the line, and you can hit space to\n// return to your last node.\n\nclass Game {\n  constructor(difficulty) {\n    this.difficulty = difficulty;\n    this.canvas = document.getElementById('canvas');\n    this.ctx = this.canvas.getContext('2d');\n\n    // this.newMazeTriggered = false;\n    // this.activateDifficultyButtons();\n    this.easy = document.getElementById(\"easy\");\n    this.medium = document.getElementById(\"medium\");\n    this.hard = document.getElementById(\"hard\");\n    this.insane = document.getElementById(\"insane\");\n\n    this.setUpGame = this.setUpGame.bind(this);\n  }\n\n  setUpGame(difficulty) {\n    this.disableDifficultyButtons();\n    this.unbindKeys();\n    this.difficulty = difficulty || this.difficulty;\n    this.cellSize = this.canvas.height / this.difficulty;\n    this.ctx.clearRect(0, 0, this.canvas.width, this.canvas.height);\n\n    this.maze = new Maze(this.difficulty, this.ctx);\n    this.maze.createMaze();\n    this.finishLine = this.maze.finishLine;\n\n    const r = (this.cellSize - 2) / 2;\n    const x = r + 1;\n    const y = r + 1;\n    this.player = new Player(x, y, r, this.ctx);\n    this.player.mazeWalls = this.maze.mapCellsToWalls();\n\n    this.maze.animateMazeBuild(\n      0,\n      this.draw.bind(this),\n      this.bindKeys.bind(this),\n      this.activateDifficultyButtons.bind(this)\n    );\n\n    // this.newMazeTriggered = false;\n  }\n\n  draw(e, handler) {\n    if (e) { this.player.moveCircle(e, handler); }\n    this.ctx.clearRect(0, 0, this.canvas.width, this.canvas.height);\n    this.maze.drawMaze();\n    this.player.drawCircle();\n    this.player.trail.drawTrail();\n    if (this.won()) {\n      this.unbindKeys();\n      this.disableDifficultyButtons();\n      window.setTimeout(this.setUpGame, 1000);\n    }\n  }\n\n  won() {\n    return (this.player.row === this.maze.finishLine.row &&\n            this.player.col === this.maze.finishLine.col);\n  }\n\n  bindKeys() {\n    // must unbind keys so they stop moving the player in previous games\n    this.unbindKeys();\n    window.key('up, down, left, right', this.draw.bind(this));\n  }\n\n  unbindKeys() {\n    window.key.unbind('up, down, left, right');\n  }\n\n  // checkIfNewMazeTriggered() {\n    // return this.newMazeTriggered;\n  // }\n\n  activateDifficultyButtons() {\n    this.easyListener = () => this.setUpGame(5);\n    this.mediumListener = () => this.setUpGame(10);\n    this.hardListener = () => this.setUpGame(25);\n    this.insaneListener = () => this.setUpGame(50);\n\n    this.easy.addEventListener(\"click\", this.easyListener);\n    this.medium.addEventListener(\"click\", this.mediumListener);\n    this.hard.addEventListener(\"click\", this.hardListener);\n    this.insane.addEventListener(\"click\", this.insaneListener);\n\n    this.easy.className = \"\";\n    this.medium.className = \"\";\n    this.hard.className = \"\";\n    this.insane.className = \"\";\n  }\n\n  disableDifficultyButtons() {\n    this.easy.removeEventListener(\"click\", this.easyListener);\n    this.medium.removeEventListener(\"click\", this.mediumListener);\n    this.hard.removeEventListener(\"click\", this.hardListener);\n    this.insane.removeEventListener(\"click\", this.insaneListener);\n\n    this.easy.className = \"disabled\";\n    this.medium.className = \"disabled\";\n    this.hard.className = \"disabled\";\n    this.insane.className = \"disabled\";\n  }\n}\n\nexport default Game;\n\n\n\n//////////////////\n// WEBPACK FOOTER\n// ./js/game.js\n// module id = 0\n// module chunks = 0","class Maze {\n  constructor(difficulty, ctx) {\n    this.difficulty = difficulty;\n    this.cellSize = ctx.canvas.height / difficulty;\n\n    this.ctx = ctx;\n    this.grid = this.createGrid();\n\n    this.finishLine = { row: this.grid.length - 1, col: this.grid.length - 1 };\n    this.finishLineImg = new Image();\n    this.finishLineImg.src = 'images/star.png';\n    this.finishLineImgLoaded = this.finishLineImg.onload = this.drawFinishLine.bind(this);\n    // this.finishLine = undefined;\n    // this.spacesMoved = 0;\n    this.orderBuilt = [];\n\n    this.carvePassagesFrom = this.carvePassagesFrom.bind(this);\n    this.animateMazeBuild = this.animateMazeBuild.bind(this);\n    this.drawFinishLine = this.drawFinishLine.bind(this);\n  }\n\n  // Allow the maze to be customized via size parameters\n  createGrid() {\n    const [rows, cols] = [this.difficulty, this.difficulty];\n    const grid = [];\n    for (let i = 0; i < rows; i++) {\n      grid[i] = new Array(cols).fill(0);\n    }\n    return grid;\n  }\n\n  createMaze() {\n    this.carvePassagesFrom(Math.floor(this.difficulty / 2), Math.floor(this.difficulty / 2), this.grid);\n  }\n\n  // Implementation of the Fisher-Yates Shuffle for randomized directions\n  shuffle(array) {\n    const shuffled = array.slice();\n    let currentIndex = shuffled.length;\n    let temporaryValue, randomIndex;\n\n    while (currentIndex !== 0) {\n      randomIndex = Math.floor(Math.random() * currentIndex);\n      currentIndex -= 1;\n\n      [shuffled[currentIndex], shuffled[randomIndex]] = [shuffled[randomIndex], shuffled[currentIndex]];\n    }\n\n    return shuffled;\n  }\n\n  // The recursive backtracking algorithm\n  carvePassagesFrom(cx, cy, grid) {\n    // Set up constants to aid with describing the passage directions\n    const [n, s, e, w] = ['n', 's', 'e', 'w'];\n    const dx = { e: 1, w: -1, n: 0, s: 0 };\n    const dy = { e: 0, w: 0, n: -1, s: 1 };\n    const opposite = { e: w, w: e, n: s, s: n };\n\n    // Randomize the directions to explore from this cell\n    const directions = this.shuffle(['n', 's', 'e', 'w']);\n    let nx, ny;\n\n    // Validates that next cell is on the grid and has not yet been explored\n    const valid = (col, row) => (\n      0 <= row && row < grid.length &&\n        0 <= col && col < grid[row].length &&\n        grid[row][col] === 0\n    );\n\n    directions.forEach(direction => {\n      nx = cx + dx[direction];\n      ny = cy + dy[direction];\n\n      // Saves a reference to the passage carved from this cell\n      if (valid(nx, ny)) {\n        grid[cy][cx] = grid[cy][cx] || direction;\n        grid[ny][nx] = grid[ny][nx] || opposite[direction];\n\n        this.orderBuilt.push({ row: ny, col: nx });\n        this.carvePassagesFrom(nx, ny, grid);\n      }\n    });\n  }\n\n  // Maps each cell in the maze into an array indicating the walls\n  // that should be drawn around it\n  mapCellsToWalls() {\n    const grid = this.grid;\n    const directions = ['n', 's', 'w', 'e'];\n    const newGrid = [];\n    const inBounds = (row, col) => (\n      0 <= row && row < grid.length &&\n        0 <= col && col < grid[row].length\n    );\n\n    grid.forEach((row, rowIdx) => {\n      let newRow = [];\n      row.map((cell, colIdx) => {\n        let paths = [cell];\n\n        if (inBounds(rowIdx - 1, colIdx) &&\n            grid[rowIdx - 1][colIdx] === 's') { paths.push('n'); }\n        if (inBounds(rowIdx + 1, colIdx) &&\n            grid[rowIdx + 1][colIdx] === 'n') { paths.push('s'); }\n        if (inBounds(rowIdx, colIdx - 1) &&\n            grid[rowIdx][colIdx - 1] === 'e') { paths.push('w'); }\n        if (inBounds(rowIdx, colIdx + 1) &&\n            grid[rowIdx][colIdx + 1] === 'w') { paths.push('e'); }\n\n        let walls = directions.filter(d => !paths.includes(d));\n        newRow.push(walls);\n      });\n      newGrid.push(newRow);\n    });\n\n    this.wallsCollection = newGrid;\n    return newGrid;\n  }\n\n  // animateMazeBuild(i, drawRestOfCanvas, bindKeys, checkIfNewMazeTriggered) {\n  animateMazeBuild(i, drawRestOfCanvas, bindKeys, activateDifficultyButtons) {\n    // debugger;\n    const indices = this.orderBuilt[i];\n    const cellSize = this.cellSize;\n\n    this.ctx.beginPath();\n    this.wallsCollection[indices.row][indices.col].forEach(wall => {\n      let xStart = cellSize * indices.col;\n      let yStart = cellSize * indices.row;\n      let xEnd, yEnd;\n\n      switch(wall) {\n        case 'n':\n        yEnd = yStart;\n        xEnd = xStart + cellSize;\n        break;\n        case 's':\n        yStart += cellSize;\n\n        yEnd = yStart;\n        xEnd = xStart + cellSize;\n        break;\n        case 'w':\n        xEnd = xStart;\n        yEnd = yStart + cellSize;\n        break;\n        case 'e':\n        xStart += cellSize;\n\n        xEnd = xStart;\n        yEnd = yStart + cellSize;\n        break;\n      }\n\n      this.ctx.moveTo(xStart, yStart);\n      this.ctx.lineTo(xEnd, yEnd);\n    });\n\n    this.ctx.lineWidth = 1;\n    this.ctx.strokeStyle = 'rgb(65, 67, 82)';\n    this.ctx.stroke();\n    this.drawFinishLine();\n\n    // if (checkIfNewMazeTriggered()) {\n      // debugger;\n      // bindKeys();\n      // return;\n    if (i < this.difficulty * this.difficulty - 2) {\n      window.requestAnimationFrame(\n        () => this.animateMazeBuild(\n          i + 1,\n          drawRestOfCanvas,\n          bindKeys,\n          activateDifficultyButtons\n          // checkIfNewMazeTriggered\n        ));\n    } else {\n      drawRestOfCanvas();\n      bindKeys();\n      activateDifficultyButtons();\n    }\n  }\n\n  // Draws the maze in canvas\n  drawMaze() {\n    const cellSize = this.cellSize;\n    let xStart, yStart;\n    let xEnd, yEnd;\n\n    this.ctx.beginPath();\n\n    this.wallsCollection.forEach((row, rowIdx) => {\n      row.forEach((cell, colIdx) => {\n        cell.forEach(wall => {\n          xStart = cellSize * colIdx;\n          yStart = cellSize * rowIdx;\n\n          switch(wall) {\n            case 'n':\n            yEnd = yStart;\n            xEnd = xStart + cellSize;\n            break;\n            case 's':\n            yStart += cellSize;\n\n            yEnd = yStart;\n            xEnd = xStart + cellSize;\n            break;\n            case 'w':\n            xEnd = xStart;\n            yEnd = yStart + cellSize;\n            break;\n            case 'e':\n            xStart += cellSize;\n\n            xEnd = xStart;\n            yEnd = yStart + cellSize;\n            break;\n          }\n\n          this.ctx.moveTo(xStart, yStart);\n          this.ctx.lineTo(xEnd, yEnd);\n        });\n      });\n    });\n    this.ctx.lineWidth = 1;\n    this.ctx.strokeStyle = 'rgb(65, 67, 82)';\n    this.ctx.stroke();\n    this.drawFinishLine();\n  }\n\n  drawFinishLine() {\n    // star.crossOrigin = 'anonymous';\n    // debugger;\n    this.ctx.drawImage(\n      this.finishLineImg,\n      this.finishLine.col * this.cellSize,\n      this.finishLine.row * this.cellSize,\n      this.cellSize,\n      this.cellSize\n    );\n  }\n}\n\nexport default Maze;\n\n\n\n//////////////////\n// WEBPACK FOOTER\n// ./js/maze.js\n// module id = 1\n// module chunks = 0","import Game from './game';\n\ndocument.addEventListener(\"DOMContentLoaded\", () => {\n  const canvas = document.getElementById('canvas');\n  canvas.width = 500;\n  canvas.height = 500;\n\n  const defaultDifficulty = 10;\n  const game = new Game(defaultDifficulty);\n  game.setUpGame();\n});\n\n\n\n//////////////////\n// WEBPACK FOOTER\n// ./js/maze_generator.js\n// module id = 2\n// module chunks = 0","import Trail from './trail';\n\nclass Player {\n  constructor(x, y, r, ctx) {\n    this.x = x;\n    this.y = y;\n    this.r = r;\n    this.ctx = ctx;\n    this.trail = new Trail(x, y, ctx);\n\n    this.row = 0;\n    this.col = 0;\n\n    this.mazeWalls = undefined;\n\n    this.movements = {\n      up: { dx: 0, dy: 2 * (-r - 1), dRow: -1, dCol: 0, dir: 'n' },\n      down: { dx: 0, dy: 2 * (r + 1), dRow: 1, dCol: 0, dir: 's' },\n      left: { dx: 2 * (-r - 1), dy: 0, dRow: 0, dCol: -1, dir: 'w' },\n      right: { dx: 2 * (r + 1), dy: 0, dRow: 0, dCol: 1, dir: 'e' }\n    };\n\n    this.moveCircle = this.moveCircle.bind(this);\n    this.drawCircle = this.drawCircle.bind(this);\n    this.animateMove = this.animateMove.bind(this);\n  }\n\n  drawCircle() {\n    const [x, y, r, ctx] = [this.x, this.y, this.r, this.ctx];\n    ctx.beginPath();\n    ctx.arc(x, y, r, 0, 2 * Math.PI, false);\n    ctx.fillStyle = 'rgb(171, 70, 67)';\n    ctx.fill();\n    ctx.lineWidth = 1;\n    ctx.strokeStyle = 'rgb(65, 67, 82)';\n    ctx.stroke();\n  }\n\n  moveCircle(e, handler) {\n    const movement = this.movements[handler.shortcut];\n    if (this.validNextMove(movement)) {\n      // const nx = this.x + movement.dx;\n      // const ny = this.y + movement.dy;\n\n      // this.animateMove(nx, ny, movement.dx, movement.dy);\n\n      this.x = this.x + movement.dx;\n      this.y = this.y + movement.dy;\n      this.row = this.row + movement.dRow;\n      this.col = this.col + movement.dCol;\n\n      this.trail.drag(this.x, this.y);\n    }\n  }\n\n  animateMove(nx, ny, dx, dy) {\n    let x = 0;\n    let y = 0;\n    //move by one pixel per frame in the appropriate dx or dy direction\n    if (dx !== 0) { x = dx < 0 ? -1 : 1; }\n    if (dy !== 0) { y = dy < 0 ? -1 : 1; }\n    // let x = dx < 0 ? -1 : 1;\n    // let y = dy < 0 ? -1 : 1;\n\n    if (Math.abs(nx - this.x) > 0 || Math.abs(ny - this.y) > 0) {\n      this.x = this.x + x;\n      this.y = this.y + y;\n      this.drawCircle();\n      window.requestAnimationFrame(() => this.animateMove(nx, ny, dx, dy));\n    }\n  }\n\n  validNextMove(movement) {\n    const next = {\n      row: this.row + movement.dRow,\n      col: this.col + movement.dCol\n    };\n\n    return this.onCanvas(next) && this.noCollision(movement.dir);\n  }\n\n  onCanvas(next) {\n    return (0 <= next.row && next.row < this.mazeWalls.length &&\n            0 <= next.col && next.col < this.mazeWalls.length);\n  }\n\n  noCollision(dir) {\n    return this.mazeWalls[this.row][this.col].indexOf(dir) < 0;\n  }\n}\n\nexport default Player;\n\n\n\n//////////////////\n// WEBPACK FOOTER\n// ./js/player.js\n// module id = 3\n// module chunks = 0","class Trail {\n  constructor(x, y, ctx) {\n    this.ctx = ctx;\n    this.path = [{ x, y }];\n  }\n\n  drag(x, y) {\n    this.path.push({ x, y });\n  }\n\n  drawTrail() {\n    this.ctx.beginPath();\n    this.ctx.moveTo(this.x, this.y);\n    this.path.forEach(point => {\n      this.ctx.lineTo(point.x, point.y);\n    });\n    this.ctx.lineWidth = 3;\n    this.ctx.strokeStyle = 'rgb(171, 70, 67)';\n    this.ctx.stroke();\n  }\n}\n\nexport default Trail;\n\n\n\n//////////////////\n// WEBPACK FOOTER\n// ./js/trail.js\n// module id = 4\n// module chunks = 0"],"sourceRoot":""}